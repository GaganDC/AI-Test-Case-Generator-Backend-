import os
import base64
import requests
import httpx

import traceback 
from fastapi import FastAPI, Request, Body,Query
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import RedirectResponse, JSONResponse
from dotenv import load_dotenv
from pydantic import BaseModel
from typing import List
from github_client import create_pull_request


load_dotenv()

app = FastAPI()



GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
GEMINI_MODEL = "models/gemini-2.5-pro"

async def call_gemini_api(prompt_text: str) -> str:
    endpoint = f"https://generativelanguage.googleapis.com/v1beta/{GEMINI_MODEL}:generateContent?key={GEMINI_API_KEY}"
    payload = {
        "contents": [
            {"parts": [{"text": prompt_text}]}
        ]
    }
    headers = {"Content-Type": "application/json"}

    async with httpx.AsyncClient(timeout=80.0) as client:
        try:
            resp = await client.post(endpoint, json=payload, headers=headers)
            resp.raise_for_status()
            result = resp.json()
            return result['candidates']['content']['parts']['text']
        except Exception as e:
            print(f"[ERROR] Gemini API call failed: {e}")
            traceback.print_exc()
            return "No output generated by Gemini."

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:5173",  # Vite dev
        "http://127.0.0.1:5173",  # Sometimes Vite uses 127.0.0.1
        "https://ai-test-case-generator-frontend.vercel.app"
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# GitHub OAuth credentials
GITHUB_CLIENT_ID = os.getenv("GITHUB_CLIENT_ID")
GITHUB_CLIENT_SECRET = os.getenv("GITHUB_CLIENT_SECRET")


@app.get("/")
def root():
    return {"message": "ðŸš€ API is running successfully"}

@app.get("/health")
def root():
    return {"status":"ok"}



@app.get("/github/login")
def github_login():
    return RedirectResponse(
        url=f"https://github.com/login/oauth/authorize?client_id={GITHUB_CLIENT_ID}&scope=repo"
    )


@app.get("/github/callback")
async def github_callback(code: str):
    print("ðŸ“© Received code:", code)

    async with httpx.AsyncClient() as client:
        token_response = await client.post(
            "https://github.com/login/oauth/access_token",
            headers={"Accept": "application/json"},
            data={
                "client_id": GITHUB_CLIENT_ID,
                "client_secret": GITHUB_CLIENT_SECRET,
                "code": code,
            },
        )
        token_json = token_response.json()
        print("ðŸªª Token response:", token_json)

        access_token = token_json.get("access_token")
        if not access_token:
            return JSONResponse(
                status_code=400,
                content={"error": "bad_verification_code", "details": token_json}
            )

        user_response = await client.get(
            "https://api.github.com/user",
            headers={"Authorization": f"Bearer {access_token}"}
        )
        user_data = user_response.json()

        repos_response = await client.get(
            "https://api.github.com/user/repos?per_page=100",
            headers={"Authorization": f"Bearer {access_token}"}
        )
        repos_data = repos_response.json()

        return {
            "access_token": access_token,
            "user": user_data,
            "repos": repos_data
        }


def fetch_directory(owner, repo, path, token):
    """Recursive fetch of files/folders from GitHub."""
    url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"
    headers = {"Authorization": f"token {token}"}
    r = requests.get(url, headers=headers)
    r.raise_for_status()
    items = r.json()

    structure = []
    for item in items:
        if item["type"] == "dir":
            structure.append({
                "name": item["name"],
                "path": item["path"],
                "type": "dir",
                "children": fetch_directory(owner, repo, item["path"], token)
            })
        else:
            structure.append({
                "name": item["name"],
                "path": item["path"],
                "type": "file",
                "download_url": item["download_url"]
            })
    return structure


@app.get("/repo-files")
def get_repo_files(owner: str, repo: str, token: str):
    
    url = f"https://api.github.com/repos/{owner}/{repo}/git/trees/main?recursive=1"
    
    headers = {"Authorization": f"token {token}"}
    r = requests.get(url, headers=headers)
    r.raise_for_status()
    data = r.json()
    

    files = []
    for item in data["tree"]:
        files.append({
            "path": item["path"],
            "name": item["path"].split("/")[-1],
            "type": "file" if item["type"] == "blob" else "dir"
        })
        
    
    return files
@app.get("/file-content")
def get_file_content(owner: str, repo: str, path: str, token: str):
    print(f"[DEBUG] /file-content called with: owner={owner}, repo={repo}, path='{path}', token={token[:8]}...")
    url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"
    headers = {"Authorization": f"token {token}"}
    r = requests.get(url, headers=headers)
    print(f"[DEBUG] GitHub response code: {r.status_code}, response: {r.text[:200]}")

    if r.status_code != 200:
        return {"error": f"Failed to fetch file: {r.text}"}

    data = r.json()
    content = base64.b64decode(data.get("content", "")).decode("utf-8")
    return {"content": content}


def fetch_file_content(owner, repo, path, token):
    url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"
    headers = {"Authorization": f"token {token}"}
    r = requests.get(url, headers=headers)
    if r.status_code != 200:
        return None, r.text
    data = r.json()
    return base64.b64decode(data.get("content", "")).decode("utf-8"), None

@app.get("/file-content")
def get_file_content(owner: str, repo: str, path: str, token: str):
    print(f"[DEBUG] /file-content called with: owner={owner}, repo={repo}, path='{path}', token={token[:8]}...")
    content, error = fetch_file_content(owner, repo, path, token)
    if error:
        return {"error": f"Failed to fetch file: {error}"}
    return {"content": content}


class TestCaseRequest(BaseModel):
    file_content: str
    language: str = "python"
    prompt: str = "Generate unit tests for the following code:"
    file_name: str = None

import json

def extract_code_from_ipynb(content_str):
    nb = json.loads(content_str)  # already decoded in get_file_content
    code_cells = [cell for cell in nb.get('cells', []) if cell.get('cell_type') == 'code']
    code = "\n\n".join("".join(cell.get('source', [])) for cell in code_cells)
    return code

@app.post("/generate-testcases")
async def generate_testcases(request: TestCaseRequest):
    GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
    if not GEMINI_API_KEY:
        return {"error": "Gemini API key not set in environment"}

    file_name = request.file_name or "unknown.py"
    ext = file_name.split('.')[-1].lower()

    language = {
        'py': 'python',
        'ipynb': 'python',
        'js': 'javascript',
        'java': 'java',
        'c': 'c',
        'cpp': 'cpp',
        'ts': 'typescript'
    }.get(ext, request.language or "python")

    # Extract Python code from .ipynb, else use plain code
    if ext == 'ipynb':
        code_str = extract_code_from_ipynb(request.file_content)
    else:
        code_str = request.file_content

    print(f"[DEBUG] Extracted code to send to Gemini:\n{code_str[:500]}")  # print first 500 chars

    prompt = (
    "You are an expert Python developer. Write comprehensive Pytest unit tests for the following Python code, "
    "including edge cases for each function and verifying dataframe manipulations where possible:\n\n"
    f"{code_str}"
)


    gemini_model = "models/gemini-2.5-pro"  # Change if needed
    gemini_endpoint = f"https://generativelanguage.googleapis.com/v1beta/{gemini_model}:generateContent?key={GEMINI_API_KEY}"

    payload = {
        "contents": [
            {
                "parts": [
                    {"text": prompt}
                ]
            }
        ]
    }

    headers = {
        "Content-Type": "application/json"
    }

    timeout = httpx.Timeout(80.0)  # 30 seconds timeout

    async with httpx.AsyncClient(timeout=timeout) as client:
        try:
            
            print("[DEBUG] Sending request to Gemini API...")
            resp = await client.post(gemini_endpoint, json=payload, headers=headers)
            print("[DEBUG] Received response from Gemini API.")

            print(f"[DEBUG] Gemini API HTTP status code: {resp.status_code}")
            print(f"[DEBUG] Gemini raw response (first 400 chars): {resp.text[:400]}")
            result = resp.json()
            print(f"[DEBUG] Gemini parsed JSON response: {result}")

        except Exception as e:
            print(f"[ERROR] Exception during Gemini API call: {e}")
            traceback.print_exc()
            return {"error": "Exception in Gemini API call: " + str(e)}
    demos = result['candidates'][0]['content']['parts'][0]['text']

    # Safely extract Gemini output
    generated_text = ""
    try:
        generated_text = result['candidates'][0]['content']['parts'][0]['text']
    except Exception:
        generated_text = "No output generated by Gemini."
    print(f"[DEBUG] Full Gemini result: {json.dumps(result, indent=2)}")

    print(f"[DEBUG] the actual code is :{generated_text}")
    
    print(f"[DEBUG] the actual code is :{demos}")
    return {"testcases": generated_text}


class TestCodeRequest(BaseModel):
    summary: str
    description: str
    codeOnly: bool = True # flag to generate only code

@app.post("/generate-testcode")
async def generate_testcode(request: TestCodeRequest):
    GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
    if not GEMINI_API_KEY:
        return {"error": "Gemini API key not set in environment"}

    # Prepare concise, code-only prompt
    prompt = (
        f"You are an expert Python developer. Given the following test case description:\n\n"
        f"{request.description}\n\n"
        "Generate only the raw Python test code using Pytest, no explanations, markdown, or extra comments."
    )

    gemini_model = "models/gemini-2.5-pro"
    gemini_endpoint = f"https://generativelanguage.googleapis.com/v1beta/{gemini_model}:generateContent?key={GEMINI_API_KEY}"

    payload = {
        "contents": [
            {
                "parts": [
                    {"text": prompt}
                ]
            }
        ]
    }
    headers = {
        "Content-Type": "application/json"
    }

    timeout = httpx.Timeout(80.0)
    async with httpx.AsyncClient(timeout=timeout) as client:
        try:
            print("[DEBUG] Sending request to Gemini API for test code...")
            resp = await client.post(gemini_endpoint, json=payload, headers=headers)
            print("[DEBUG] Received response from Gemini API.")
            print(f"[DEBUG] HTTP status: {resp.status_code}")
            print(f"[DEBUG] Raw response (first 400 chars): {resp.text[:400]}")

            result = resp.json()
            print(f"[DEBUG] Parsed Gemini JSON: {json.dumps(result, indent=2)[:500]}")

            generated_code = result['candidates'][0]['content']['parts'][0]['text']
        except Exception as e:
            print(f"[ERROR] Exception during Gemini API call: {e}")
            traceback.print_exc()
            generated_code = "No code generated by Gemini."

    print(f"[DEBUG] Generated test code: {generated_code[:500]}")
    return {"generatedCode": generated_code}



class PRRequest(BaseModel):
    repo_full_name: str
    branch_name: str
    file_path: str
    file_content: str
    pr_title: str
    pr_body: str

@app.post("/create-pr")
async def create_pr_endpoint(req: PRRequest):
    token = os.getenv("GITHUB_TOKEN")
    if not token:
        return {"error": "Missing GitHub token"}

    try:
        pr_url = create_pull_request(
            token=token,
            repo_full_name=req.repo_full_name,
            new_branch_name=req.branch_name,
            file_path=req.file_path,
            file_content=req.file_content,
            pr_title=req.pr_title,
            pr_body=req.pr_body,
        )
        return {"prUrl": pr_url}
    except Exception as e:
        return {"error": str(e)}